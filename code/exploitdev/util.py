#!/usr/bin/python
#
# Util.py
# Utilities for binary exploitation

import struct

def nops(length):
	return "\x90" * length

def patch(opcodes, instructions, data):
	# Replace instructions in a set of opcodes with the given data.
	# Useful to patch shellcode for bad characters
	#
	# patch(shellcode, "\xb0\x0b", "\xb0\x0e\x2c\x03")
	index = opcodes.find(instructions)
	return opcodes[:index] + data + opcodes[index + len(instructions):]

def bytes_to_hex(data):
    hex_values = struct.unpack("B" * len(data), data)
    hex_values = [hex(b)[2:].zfill(2) for b in hex_values]
    return hex_values

def asciify(hex_data):    
    def get_printable_char(c):
        return chr(c) if c in range(0x20, 0x7f) else '.'
    return [get_printable_char(int(c, 16)) for c in hex_data]

def pp_hexdump(data, width=16):
    # Pretty print a byte string as a hex dump.
    assert width % 4 == 0 and width != 0, "width must be a multiple of 4"
    hex_values = bytes_to_hex(data)
    result = "Length: {} bytes\n".format(len(data))   
    
    for i in range(0, len(hex_values), width):
        hex_row = hex_values[i:i + width] 
        ascii_row = asciify(hex_row)

        hex_row_result = ""
        for j in range(0, len(hex_row), 4):
            hex_row_result += " ".join(hex_row[j:j + 4])
            hex_row_result += "  "

        ascii_row_result = "".join(ascii_row)
        
        result += "{:{hw}} {}\n".format(
            hex_row_result, ascii_row_result, 
            hw=((width * 2) + 20))
        
    return result[:-1] # remove the last newline

def pp_little_endian(data):
    # Pretty print a byte string in little endian format
    hex_values = bytes_to_hex(data)
    result = ""
    for i in range(0, len(hex_values), 4):
        word = "".join(hex_values[i:i + 4][::-1]).zfill(8)
        word = "0x" + word
        result += word
        if (i + 4) % 16 == 0:
            result += "\n"
        else:
            result += "\t"
    return result 
