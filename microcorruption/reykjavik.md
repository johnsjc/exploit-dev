## 5. Reykjavik

**Objective:** Using the MSP430 disassembler

In this challenge, we notice something very strange in the **main** function.

```
443e:  3e40 f800      mov	#0xf8, r14
4442:  3f40 0024      mov	#0x2400, r15
4446:  b012 8644      call	#0x4486 <enc>
444a:  b012 0024      call	#0x2400
```

After a suspicious function called enc, we call an address with no symbol. If we examine memory at that location, we find that it is empty.

```
2400:   0000 0000 0000 0000  ........
2408:   0000 0000 0000 0000  ........
2410:   0000 0000 0000 0000  ........
2418:   0000 0000 0000 0000  ........
```

This means that after the call at 0x4446, these instructions **must** be populated. If we set a breakpoint at 0x444a, we can see what memory looks like after the enc function runs. Something else that is interesting is the value being stored in r14 as an argument to the enc function. 0xf8 (248) probably is the number of bytes to write to memory at 0x2400.

After the enc function runs, let's grab the first 248 bytes starting at address 0x2400.

```
0b12 0412 0441 2452 3150 e0ff 3b40 2045
073c 1b53 8f11 0f12 0312 b012 6424 2152
6f4b 4f93 f623 3012 0a00 0312 b012 6424
2152 3012 1f00 3f40 dcff 0f54 0f12 2312
b012 6424 3150 0600 b490 8d61 dcff 0520
3012 7f00 b012 6424 2153 3150 2000 3441
3b41 3041 1e41 0200 0212 0f4e 8f10 024f
32d0 0080 b012 1000 3241 3041
```

Using the MSP430 disassembler, we do find that these are actual opcodes!

The most interesting part of the disassembly is the following section:
```
b490 8d61 dcff cmp	#0x618d, -0x24(r4)
0520           jnz	$+0xc
3012 7f00      push	#0x7f
b012 6424      call	#0x2464
```

0x2464 refers to the INT function, and passing the argument 0x7f prior to calling it opens the door without supplying a password. In order to do that, we need to make sure we don't take the jump. It looks like some kind of byte needs to be present in our password for that not to happen.

The opcodes for the cmp instruction are at the 36th offset in the dword opcodes. Since this is a 16bit architecture, we need to multiply this value by 2 to get 72. If we convert it to hexadecimal, we get 48. So, we set a breakpoint at 2448 to see what the value of -0x24(r4) is at this point.

If we inspect memory, we see that the cmp is operating on the very first dword of our input. So in order to not take the jump, we just need to supply a password beginning with 0x618d, accounting for endianness, of course.

**Flag:** **8d61**
