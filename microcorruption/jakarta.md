## 11. Jakarta

**Objective:** Buffer overflow, Integer underflow

The program claims that the username and password cannot be more than 32 characters combined. And it seems that there are some checks to make sure of that..

After the username is read in, a loop counts the number of characters and there is a comparison to 0x21, which is 33 in hex.

```
4592:  3f40 0124      mov	#0x2401, r15
4596:  1f53           inc	r15
4598:  cf93 0000      tst.b	0x0(r15)
459c:  fc23           jnz	#0x4596 <login+0x36>
459e:  0b4f           mov	r15, r11
. . .
45ae:  7b90 2100      cmp.b	#0x21, r11
45b2:  0628           jnc	#0x45c0 <login+0x60>
```
After the password is prompted for, there is some interesting arithmetic with the registers.

```
45c8:  3e40 1f00      mov	#0x1f, r14
45cc:  0e8b           sub	r11, r14
45ce:  3ef0 ff01      and	#0x1ff, r14
45d2:  3f40 0224      mov	#0x2402, r15
45d6:  b012 b846      call	#0x46b8 <getsn>
```

This is effectively limiting how many bytes will be read for the password. The gets function takes two arguments passed through registers r14 and r15. 

r14 is being set to the value of 0x1f minus r11 (the length of our username). This is the bounds check to make sure the username and password lengths combined are 32 or less.

However, there is a nasty bug here. If we have a username length of 32, then the value of r14 after the subtraction operation will be -1 or 0xffff. This is an **integer underflow.** 

After the and operation, r14 will contain the value 0x1ff, or 511 bytes. That's a lot better to work with.

There is one more check before main returns.

```
45ee:  3f40 0124      mov	#0x2401, r15
45f2:  1f53           inc	r15
45f4:  cf93 0000      tst.b	0x0(r15)
45f8:  fc23           jnz	#0x45f2 <login+0x92>
45fa:  3f80 0224      sub	#0x2402, r15
45fe:  0f5b           add	r11, r15
4600:  7f90 2100      cmp.b	#0x21, r15
4604:  0628           jnc	#0x4612 <login+0xb2>
```

After the password is read, r15 is incremented and represents the length. Then r11 (the username length) and r15 (the password length) are added together. This is one final check to make sure that the lengths were enforced. There is a bug here, though.

At 0x4600, where the comparison is taking place, it is a **cmp.b** instruction. This means it is only comparing the **byte**. If we make the password long enough so that the lower byte is still less than 0x21, it will pass this check.

We can do some basic hexadecimal arithmetic to find a good value. Let's write as many bytes as possible just in case.

**0x120** (total length) - **0x20** (username length) = **0x100** (password length)

So we need to write 0x100 or 256 bytes to the password.

Using 32 junk bytes for the username and a 256 byte pattern string for the password, we can find the offset where sp is pointing to after main finishes.

```
Content of sp:
4016:   6131 4161 3241 6133  a1Aa2Aa3
401e:   4161 3441 6135 4161  Aa4Aa5Aa
```

In this case, it is only pointing to the 5th byte. We still need to write enough bytes to pass the last bounds check, so we will use the following payloads:

Username
- 32 bytes of junk

Password
 - 4 bytes of junk
 - 4c44 (address of unlock_door)
 - 250 bytes of junk

**Flag (username):**
**AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA**

**Flag (password):**
BBBB**LD**CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

**Note:** LD is the ASCII representation for 4c44.
