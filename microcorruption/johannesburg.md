## 7. Johannesburg

**Objective**: Buffer Overflow (write memory and control IP)

Again, this program accepts more input than it should. You can write 0x3F (63) bytes of data to the buffer for the password when the program tells you it must only be a maximum of 16.

```
4546:  3e40 3f00      mov	#0x3f, r14
454a:  3f40 0024      mov	#0x2400, r15
454e:  b012 e845      call	#0x45e8 <getsn>
```

Let's use a 63 character pattern string as our input for the password.

Even though the buffer allows you to write more than 16 bytes to it, there is still a small check later in the program:

```
4578:  f190 1000 1100 cmp.b	#0x10, 0x11(sp)
457e:  0624           jeq	#0x458c <login+0x60>
```

However, since we can overflow the buffer, we can just write this byte to the required memory location to pass the check.

We set breakpoints at the check at 0x4578 and at the end of main.

When we read the contents of 0x11(sp) at the break point, we find that it is looking at the 18th character offset. Altering our string to consist of 17 junk bytes followed by 10 and then some more junk, we can continue to the end of the function. If we check the contents of sp when ret is executed, we find that it is pointing at the 19th byte of our input. This means we control IP as well.

Let's overwrite the stack pointer so that the program executes unlock_door at address 0x4446 after it returns from main.

**Flag:** 4141414141414141414141414141414141**104644**
