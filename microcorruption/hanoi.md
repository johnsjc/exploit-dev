## 4. Hanoi

**Objective:** Buffer Overflow (Overwriting memory)

This is a very simple buffer overflow attack. If we check **main** we can see something interesting:

```
452c:  3f40 9e44      mov	#0x449e "Remember: passwords are between 8 and 16 characters.", r15
4530:  b012 de45      call	#0x45de <puts>
4534:  3e40 1c00      mov	#0x1c, r14
4538:  3f40 0024      mov	#0x2400, r15
453c:  b012 ce45      call	#0x45ce <getsn>
```

Even though the program says that passwords are between 8 and 16 characters long, if we examine the **getsn** call, we can see otherwise.

getsn takes two arguments: the buffer and the size. Since arguments are pushed in reverse order onto the stack, we can see that r14 is the size, and r15 is the buffer. Our string will be stored in memory at 0x2400, but we can write a total of **0x1c (28)** bytes to the buffer.

If we submit a pattern string that is 28 bytes long such as Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8A  and watch the registers, we don't find any way to control the instruction pointer - bummer. But this challenge is more simple than that. If we look a bit further down in main, there is a single check:

```
455a:  f290 1b00 1024 cmp.b	#0x1b, &0x2410
4560:  0720           jne	#0x4570 <login+0x50>
4562:  3f40 f144      mov	#0x44f1 "Access granted.", r15
4566:  b012 de45      call	#0x45de <puts>
456a:  b012 4844      call	#0x4448 <unlock_door>
```

There is a byte comparison at memory address 0x2410. Apparently, the HSM attached to this lock marks this byte in memory if the password is correct. Since this is at the 17th byte from where the password is stored, we can exploit the fact that we can write more than 16 bytes to the password buffer and write the desired byte value to bypass the security check.

**Flag:** 41414141414141414141414141414141**1b**
