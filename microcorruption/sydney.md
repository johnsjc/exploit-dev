## 3. Sydney

**Objective**: Endianness

Similar to the last challenge, the password is hard-coded. We can see the logic in the **check_password** function:

```
448a <check_password>
448a:  bf90 667a 0000 cmp	#0x7a66, 0x0(r15)
4490:  0d20           jnz	$+0x1c
4492:  bf90 3961 0200 cmp	#0x6139, 0x2(r15)
4498:  0920           jnz	$+0x14
449a:  bf90 557d 0400 cmp	#0x7d55, 0x4(r15)
44a0:  0520           jne	#0x44ac <check_password+0x22>
44a2:  1e43           mov	#0x1, r14
44a4:  bf90 566a 0600 cmp	#0x6a56, 0x6(r15)
44aa:  0124           jeq	#0x44ae <check_password+0x24>
44ac:  0e43           clr	r14
44ae:  0f4e           mov	r14, r15
44b0:  3041           ret
```

The value in r15 is the location on the stack where our inputted password lives. dwords (4 bytes) are being checked at offsets of this string. If there are any discrepancies, the function immediately ends with r15 being set to zero. Otherwise, the function returns without modifying r15 (which is a nonzero value). Just like in the last challenge, if r15 is nonzero, the lock opens.

The crux of this problem is knowing that the hex-encoded input needs to be inputted differently because the MSP430 stores bytes in **little endian** format. This means that the least significant bits are stored **first**. Since the MSP430 is a 16-bit architecture, the dwords, which are 32 bits, need to be split in half for this purpose. i.e, 0x7a66 becomes 0x66 and 0x7a.

**Flag**: **667a3961557d566a**
