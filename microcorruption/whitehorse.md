## 8. Whitehorse

**Objective**: Buffer Overflow and Shellcode

Again, this program is vulnerable to a buffer overflow attack. Even though the password is said to only be a maximum of 16 characters, getsn allows us to write 0x30 (48) bytes to the buffer. So, let's do that.

```
4508:  3e40 3000      mov	#0x30, r14
450c:  0f41           mov	sp, r15
450e:  b012 8645      call	#0x4586 <getsn>
```

Let's also put a breakpoint at the end of main to see if we can control IP.

After inspecting sp after hitting our breakpoint, we find that it is pointing at the 17th byte in our input string. This means we can control the program execution!

There is only one problem: where do we jump to?

After retrieving the password from the user, the program calls **conditional_unlock_door** which uses argument 0x7e when calling INT. This requires us to know the password, so we can't use this function. There are no other useful functions we can use, so we will have to write our own opcodes to memory and execute them. This is  called **Shellcode**.

We have 48 bytes to play with for our shellcode, but we shouldn't need that many. What we want to do is call INT with the argument 0x7f to open the door without supplying any password.

Using the assembler and the conditional_unlock_door function as a template, we can assemble the required opcodes for this.

Instructions:
```
push	#0x7f
call	#0x4532 <INT>
```

Assembled opcodes:
```
3012 7f00 b012 3245
```

An important thing to remember is that sp points to an address. We need to load our shellcode into memory, and then point to the start of it with sp after main finishes executing. An easy way to do this is to craft an input that contains our shellcode, some junk bytes for padding up to the value to overwrite sp, and then the address where our shellcode is stored in memory.

If we inspect memory at the end of main, we can see that our shellcode is stored at address 0x3a70.

Putting it all together, we have
- shellcode (8 bytes)
- 8 bytes of junk padding
- 703a

**Flag:** **30127f00b0123245**4141414141414141**703a**

**Note:** the **gets** function doesn't care about null bytes in the input string. It reads characters until it receives EOF or a newline character. This is why we can have a null byte **00** in our shellcode.
